// 백준 2225번 : 합분해

/*
숫자 n을 k개의 수의 합으로 분해한다
이때 1+2랑 2+1은 다르고 1+0, 1+0+0, 1+0+0+0... 도 가능하다
--> 점화식 이쁘게 쓸 수 있는 dp네?? 쉽겠다!
라고 생각했지만 다섯 번이나 틀렸습니다를 보고 겨우 맞췄다 ^^...후
*/

/*
dp[n][k] : k개 수를 합해서 n 만드는 경우의 수


dp[0][1] = 1	0
dp[0][2] = 1	0+0
dp[0][3] = 1	0+0+0

dp[1][1] = 1	1
dp[1][2] = 2	0+1 / 1+0
dp[1][3] = 3	0+0+1 / 0+1+0, 1+0+0
dp[1][4] = 4 	0+0+0+1 / 0+0+1+0, 0+1+0+0, 1+0+0+0

dp[2][1] = 1	2
dp[2][2] = 3	0+2 / 1+1 / 2+0
dp[2][3] = 6	0+0+2 / 0+1+1, 1+0+1 / 0+2+0, 1+1+0, 2+0+0
dp[2][4] = 10	0+0+2+0, 0+1+1+0, 1+0+1+0, 0+2+0+0, 1+1+0+0, 2+0+0+0 / 0+0+1+1, 0+1+0+1, 1+0+0 / 0+0+0+2


k개로 n만들기
= (k-1개로 n만들고 0더하기) + (k-1개로 n-1만들고 1더하기) + (k-1개로 n-2만들고 2더하기) ...

	-> n-t만들고 t더하기 << t는 0부터 n까지
*/


#include <stdio.h>

#define mod 1000000000
#define ll long long

int n, k;

ll dp[205][205];
// dp[n][k] : k개의 수를 합해서 n을 만드는 경우의 수

int main() {
	scanf("%d%d", &n, &k);

	for (int i = 0; i <= n; i++) dp[i][1] = 1;
	// 숫자 1개로 i를 만들려면 'i' << 한 가지


	for (int i = 0; i <= n; i++) {
		/*
		여기서 i=1부터 시작하면 틀리더라..... 이거 떄문에 계속 틀렸다
		*/
		for (int j = 2; j <= k; j++) {
			for (int t = 0; t <= i; t++) {
				dp[i][j] += dp[i - t][j - 1];
				dp[i][j] %= mod;
				// j개로 i 만들기 = j-1개로 i-t 만들고 뒤에 +t 하기
			}
		}
	}

	printf("%d", dp[n][k]);
}

