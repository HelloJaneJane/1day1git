// ALOHA 여름 멘토링 중급반 : DP
// 백준 10164번 - 격자상의 경로

/*
k가 0일 때 : 경유지가 없다
 -> (1,1)에서 (c,r)로 가는 총 경우의 수
k가 0이 아닐 때 : 경유지가 1개 있다
 -> (1,1)에서 (경유지), (경유지)에서 (c,r)로 가는 경우의 수를 곱한다 

 어차피 경우의 수니까..

     (0)(1)(2)(3)(4)
 (0)
 (1)	 1  1  1  1
 (2)	 1  2  3  4
 (3)	 1  3  6  10
 (4)	 1  4  10 20
 
 이렇게 dp 배열을 채워넣어둔 다음에 갖다 쓰면 됨
 */

/*
경유지 번호를 좌표로 바꿀라면...

예제 : r=3 / c=5 / k=8 = 5*1+3

x=3 = 8%5 = k%c
y=2 = 8/5+1 = k/c+1

(1,1)~(x,y) + (x,y)~(c,r)
-> dp(x,y) * dp(c-x+1,r-y+1)


근데 예외있음!! k가 c로 나눠떨어질 때..
x값 y값 둘다 조절해줘야함 (처음에 y는 그냥해버려서 틀렸음ㅠ)
r=3 c=5 k=10 -> x=5, y=2
r=3 c=5 k=11 -> x=1, y=3
*/


#include <stdio.h>

int r, c, k;

int dp[16][16];

int get_dp(int x, int y) {
	for (int i = 1; i <= y; i++) {
		for (int j = 1; j <= x; j++) {
			// 그 좌표에 dp값이 이미 있으면 패쓰, 없으면 채우기
			if (!dp[i][j]) {
				if (i == 1 || j == 1) dp[i][j] = 1;			// 첫줄은 1
				else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // 위에꺼+왼쪽꺼
			}
		}
	}
	return dp[y][x];
}

int main() {
	scanf("%d%d%d", &r, &c, &k);

	int ans;

	if (k) { // 경유지가 한 개 있을 때
		int x = k % c;
		int y = k / c + 1;
		if (x == 0) { // k가 c로 나눠떨어지면 예외
			x = c;
			y = k / c;
		}

		ans = get_dp(x, y) * get_dp(c - x + 1, r - y + 1);
	}
	else { // 경유지가 없을 때
		ans = get_dp(c, r);
	}

	printf("%d", ans);
}

